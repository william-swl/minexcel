{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"minexcel","text":"<p>\u4e2d\u6587\u6587\u6863</p> <p><code>minexcel</code> is a Python package designed for processing complex Excel tables and extracting structured data blocks from formatted layouts.</p>"},{"location":"#reading-formatted-data-blocks-in-excel","title":"Reading Formatted Data Blocks in Excel","text":"<p>Formatted data blocks in Excel are often challenging to parse, especially when merged cells are involved. <code>minexcel</code> abstracts the cells in data block into distinct components and supports simplified markup for configuration.</p> <p>To define a template, you can create a new <code>.xlsx</code> file and structure your data block as follows:</p> <ul> <li> <p><code>[tablemeta]</code>: Table metadata. Each block can have multiple table metadata entries, but each entry must contain a single value.</p> </li> <li> <p><code>[rowmeta]</code>: Row metadata. Represents row-wise extended information, including traditional rownames.</p> </li> <li> <p><code>[colmeta]</code>: Column metadata. Represents column-wise extended information including traditional colnames.</p> </li> <li> <p>Leave empty: Core data area. This region should contain no rowname or colname.</p> </li> <li> <p><code>[ignore]</code>: Cells to skip during parsing. Note: The original cell containing the metadata name must be marked as <code>[ignore]</code>.</p> </li> </ul> <p></p> <p>Use <code>minexcel</code> to parse the data:</p> <pre><code>import minexcel as mxl\n\ntmpl = mxl.parse_template(\"template.xlsx\")\nres = mxl.read_block_excel(\"data.xlsx\", tmpl)\n</code></pre> <p>This returns structured data matching the template's design:</p> <p></p>"},{"location":"index-CN/","title":"minexcel","text":"<p><code>minexcel</code> \u662f\u4e00\u4e2a\u5904\u7406\u590d\u6742 Excel \u8868\u683c\uff0c\u6316\u6398\u6709\u6548\u6570\u636e\u7684 python \u5305</p>"},{"location":"index-CN/#excel-block","title":"\u8bfb\u53d6 excel \u4e2d\u683c\u5f0f\u5316\u7684\u6570\u636e block","text":"<p>excel \u4e2d\u683c\u5f0f\u5316\u7684\u6570\u636e block \u5e38\u5e38\u96be\u4ee5\u88ab\u7b80\u5355\u8bfb\u53d6\uff0c\u5728\u6d89\u53ca\u5230\u5408\u5e76\u5355\u5143\u683c\u65f6\u66f4\u662f\u5982\u6b64\u3002<code>minexcel</code> \u5c06\u6570\u636e block \u62bd\u8c61\u4e3a\u51e0\u79cd\u7ec4\u6210\u90e8\u5206\uff0c\u5e76\u652f\u6301\u7528\u7b80\u6613\u7684\u6807\u8bb0\u8868\u793a</p> <p>\u4f60\u53ef\u4ee5\u65b0\u5efa\u4e00\u4e2a<code>.xlsx</code>\u6587\u4ef6\uff0c\u6309\u4ee5\u4e0b\u683c\u5f0f\u8f93\u5165\u6570\u636e block \u7684\u6a21\u677f\uff1a</p> <ul> <li> <p><code>[tablemeta]</code>\uff1a\u8868\u683c\u5143\u6570\u636e\u3002\u6bcf\u4e2a block \u53ef\u4ee5\u6709\u591a\u4e2a\u8868\u683c\u5143\u6570\u636e\uff0c\u4f46\u6bcf\u4e2a\u8868\u683c\u5143\u6570\u636e\u53ea\u80fd\u6709\u4e00\u4e2a\u503c</p> </li> <li> <p><code>[rowmeta]</code>\uff1a\u884c\u5143\u6570\u636e\u3002\u6570\u636e\u5728\u884c\u65b9\u5411\u7684\u6269\u5c55\u4fe1\u606f\uff0c\u5305\u62ec\u4f20\u7edf\u7684\u884c\u540d</p> </li> <li> <p><code>[colmeta]</code>\uff1a\u5217\u5143\u6570\u636e\u3002\u6570\u636e\u5728\u5217\u65b9\u5411\u7684\u6269\u5c55\u4fe1\u606f\uff0c\u5305\u62ec\u4f20\u7edf\u7684\u5217\u540d</p> </li> <li> <p>\u7559\u7a7a\uff1a\u6838\u5fc3\u6570\u636e\u533a\u57df\u3002\u8be5\u533a\u57df\u5e94\u8be5\u65e0\u884c\u540d\u3001\u65e0\u5217\u540d</p> </li> <li> <p><code>[ignore]</code>\uff1a\u89e3\u6790\u65f6\u5ffd\u7565\u7684\u5355\u5143\u683c\u3002\u6ce8\u610f\uff0c\u539f\u8868\u683c\u4e2d\u5143\u6570\u636e\u540d\u79f0\u6240\u5728\u7684\u5355\u5143\u683c\uff0c\u5e94\u6807\u8bb0\u4e3a<code>[ignore]</code></p> </li> </ul> <p></p> <p>\u968f\u540e\uff0c\u4f7f\u7528 <code>minexcel</code> \u89e3\u6790</p> <pre><code>import minexcel as mxl\n\ntmpl = mxl.parse_template(\"template.xlsx\")\nres = mxl.read_block_excel(\"data.xlsx\", tmpl)\n</code></pre> <p>\u53ef\u5f97\u5230\u7ed3\u6784\u5316\u7684\u6570\u636e</p> <p></p>"},{"location":"reference/","title":"minexcel","text":""},{"location":"reference/#minexcel.block.parse_block","title":"<code>parse_block(block, tmpl)</code>","text":"<p>Parses a structured data block into a DataFrame using a template definition.</p> <p>This function processes a DataFrame according to a template specification that defines: - Table-level metadata locations - Row metadata ranges - Column metadata ranges - Data value locations The parsed result combines metadata with data values in long format.</p> <p>Parameters:</p> Name Type Description Default <code>block</code> <code>DataFrame</code> <p>Input DataFrame containing structured data to be parsed. Expected shape: (tmpl['block_nrow'], tmpl['block_ncol'])</p> required <code>tmpl</code> <code>Dict[str, Any]</code> <p>Template dictionary defining the block structure. Expected keys: 'block_nrow': Expected number of rows in block 'block_ncol': Expected number of columns in block 'tablemeta': Dict of {metadata_key: (row, col)} positions 'rowmeta': Dict of {metadata_key: {'col': col_index, 'start': start_row, 'end': end_row}} 'colmeta': Dict of {metadata_key: {'row': row_index, 'start': start_col, 'end': end_col}} 'data_rows_list': List of row indices containing data values 'data_cols_list': List of column indices containing data values</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: DataFrame containing: - 'row_index': Original row index - 'col_index': Original column index - 'value': Data value from the block - Columns for each tablemeta key with corresponding values - Columns for each rowmeta key with row-level metadata - Columns for each colmeta key with column-level metadata</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If input block dimensions don't match template specifications</p> Source code in <code>src/minexcel/block.py</code> <pre><code>def parse_block(block: pd.DataFrame, tmpl: Dict[str, Any]) -&gt; pd.DataFrame:\n    \"\"\"\n    Parses a structured data block into a DataFrame using a template definition.\n\n    This function processes a DataFrame according to a template specification that defines:\n    - Table-level metadata locations\n    - Row metadata ranges\n    - Column metadata ranges\n    - Data value locations\n    The parsed result combines metadata with data values in long format.\n\n    Args:\n        block: Input DataFrame containing structured data to be parsed.\n            Expected shape: (tmpl['block_nrow'], tmpl['block_ncol'])\n        tmpl: Template dictionary defining the block structure. Expected keys:\n            'block_nrow': Expected number of rows in block\n            'block_ncol': Expected number of columns in block\n            'tablemeta': Dict of {metadata_key: (row, col)} positions\n            'rowmeta': Dict of {metadata_key: {'col': col_index, 'start': start_row, 'end': end_row}}\n            'colmeta': Dict of {metadata_key: {'row': row_index, 'start': start_col, 'end': end_col}}\n            'data_rows_list': List of row indices containing data values\n            'data_cols_list': List of column indices containing data values\n\n    Returns:\n        pd.DataFrame: DataFrame containing:\n            - 'row_index': Original row index\n            - 'col_index': Original column index\n            - 'value': Data value from the block\n            - Columns for each tablemeta key with corresponding values\n            - Columns for each rowmeta key with row-level metadata\n            - Columns for each colmeta key with column-level metadata\n\n    Raises:\n        AssertionError: If input block dimensions don't match template specifications\n\n    \"\"\"\n    # Validate input block matches template dimensions\n    assert block.shape == (tmpl[\"block_nrow\"], tmpl[\"block_ncol\"])\n\n    # Store original indexes for later reconstruction\n    block_raw_row_idx = block.index\n    block_raw_col_idx = block.columns\n\n    # Convert to position-based integer indexes\n    block = pd.DataFrame(block.values)\n    # Create mapping between positional indexes and original indexes\n    row_idx_map = dict(zip(block.index, block_raw_row_idx))\n    col_idx_map = dict(zip(block.columns, block_raw_col_idx))\n\n    # Extract table-level metadata\n    block_tablemeta: Dict[str, Any] = {}\n    if tmpl[\"tablemeta\"]:\n        for key, pos in tmpl[\"tablemeta\"].items():\n            value = block.loc[pos[0], pos[1]]\n            block_tablemeta[key] = value\n\n    # Extract row-level metadata\n    block_rowmeta: Dict[str, Dict[Any, Any]] = {}\n    if tmpl[\"rowmeta\"]:\n        for key, pos in tmpl[\"rowmeta\"].items():\n            # Slice row metadata range\n            values = dict(block.iloc[pos[\"start\"] : pos[\"end\"] + 1, pos[\"col\"]].items())\n            block_rowmeta[key] = values\n\n    # Extract column-level metadata\n    block_colmeta: Dict[str, Dict[Any, Any]] = {}\n    if tmpl[\"colmeta\"]:\n        for key, pos in tmpl[\"colmeta\"].items():\n            # Slice column metadata range\n            values = dict(block.iloc[pos[\"row\"], pos[\"start\"] : pos[\"end\"] + 1].items())\n            block_colmeta[key] = values\n\n    # Extract core data values\n    data = block.iloc[tmpl[\"data_rows_list\"], tmpl[\"data_cols_list\"]]\n\n    # Convert data to long format (styled structure)\n    result = data.reset_index(names=\"row_index\").melt(\n        id_vars=\"row_index\", var_name=\"col_index\", value_name=\"value\"\n    )\n\n    # Merge metadata into result\n    for k, v in block_tablemeta.items():\n        result[k] = v\n\n    for k, d in block_rowmeta.items():\n        result[k] = [d.get(i, None) for i in result[\"row_index\"].to_list()]\n\n    for k, d in block_colmeta.items():\n        result[k] = [d.get(i, None) for i in result[\"col_index\"].to_list()]\n\n    # Restore original indexes\n    result[\"row_index\"] = [row_idx_map[i] for i in result[\"row_index\"]]\n    result[\"col_index\"] = [col_idx_map[i] for i in result[\"col_index\"]]\n\n    return result\n</code></pre>"},{"location":"reference/#minexcel.block.parse_template","title":"<code>parse_template(template_file)</code>","text":"<p>Parses an Excel template file to extract metadata information about its structure.</p> <p>This function analyzes an Excel template and returns a dictionary containing: - Dimensions of the entire template and data blocks - Positions of row and column metadata markers - Table-level metadata positions - Validation checks for template structure</p> <p>Parameters:</p> Name Type Description Default <code>template_file</code> <code>str</code> <p>Path to the Excel template file (.xlsx) to be parsed</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary with the following structure:</p> <code>Dict[str, Any]</code> <ul> <li>'block_nrow': int,          # Total rows in template</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'block_ncol': int,          # Total columns in template</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'data_nrow': int,           # Number of rows in data zone</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'data_ncol': int,           # Number of columns in data zone</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'data_rows_list': List[int], # Row indices in data zone</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'data_cols_list': List[int], # Column indices in data zone</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'tablemeta': Dict[str, Tuple[int, int]], # Table metadata positions</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'rowmeta': Dict[str, Dict[str, int]],    # Row metadata definitions</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'colmeta': Dict[str, Dict[str, int]]     # Column metadata definitions</li> </ul> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the template structure doesn't meet requirements:</p> <ul> <li>Data zone must be contiguous</li> <li>Each rowmeta key must appear only in a single column</li> <li>Each colmeta key must appear only in a single row</li> <li>Metadata ranges must be serial and within data zone</li> </ul> Source code in <code>src/minexcel/block.py</code> <pre><code>def parse_template(template_file: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Parses an Excel template file to extract metadata information about its structure.\n\n    This function analyzes an Excel template and returns a dictionary containing:\n    - Dimensions of the entire template and data blocks\n    - Positions of row and column metadata markers\n    - Table-level metadata positions\n    - Validation checks for template structure\n\n    Args:\n        template_file: Path to the Excel template file (.xlsx) to be parsed\n\n    Returns:\n        A dictionary with the following structure:\n\n        - 'block_nrow': int,          # Total rows in template\n        - 'block_ncol': int,          # Total columns in template\n        - 'data_nrow': int,           # Number of rows in data zone\n        - 'data_ncol': int,           # Number of columns in data zone\n        - 'data_rows_list': List[int], # Row indices in data zone\n        - 'data_cols_list': List[int], # Column indices in data zone\n        - 'tablemeta': Dict[str, Tuple[int, int]], # Table metadata positions\n        - 'rowmeta': Dict[str, Dict[str, int]],    # Row metadata definitions\n        - 'colmeta': Dict[str, Dict[str, int]]     # Column metadata definitions\n\n    Raises:\n        AssertionError: If the template structure doesn't meet requirements:\n\n            - Data zone must be contiguous\n            - Each rowmeta key must appear only in a single column\n            - Each colmeta key must appear only in a single row\n            - Metadata ranges must be serial and within data zone\n\n    \"\"\"\n    result = {\n        \"block_nrow\": None,\n        \"block_ncol\": None,\n        \"data_nrow\": None,\n        \"data_ncol\": None,\n        \"data_rows_list\": None,\n        \"data_cols_list\": None,\n        \"tablemeta\": {},\n        \"rowmeta\": {},\n        \"colmeta\": {},\n    }\n\n    tmpl_df = read_excel_with_merged_cell(template_file)\n\n    # 1. Get basic dimensions\n    result[\"block_nrow\"], result[\"block_ncol\"] = tmpl_df.shape\n\n    # 2. Identify data zone (non-blank areas)\n    data_cols = tmpl_df.isna().sum(axis=0) != 0\n    data_cols_list = data_cols[data_cols].index.to_list()\n\n    data_rows = tmpl_df.isna().sum(axis=1) != 0\n    data_rows_list = data_rows[data_rows].index.to_list()\n\n    # 3. Validate data zone is contiguous\n    assert check_int_serial(data_cols_list), \"Data columns must be contiguous\"\n    assert check_int_serial(data_rows_list), \"Data rows must be contiguous\"\n\n    result[\"data_cols_list\"] = data_cols_list\n    result[\"data_rows_list\"] = data_rows_list\n    result[\"data_nrow\"], result[\"data_ncol\"] = tmpl_df.loc[data_rows, data_cols].shape\n\n    # 4. Extract metadata\n    # Table-level metadata (can appear anywhere)\n    for irow, row in tmpl_df.iterrows():\n        for icol, cell in enumerate(row):\n            if not isinstance(cell, str):\n                continue\n            match_res = re.match(r\"(\\w+)\\[tablemeta\\]\", str(cell))\n            if match_res:\n                key = match_res.group(1)\n                result[\"tablemeta\"].setdefault(key, []).append((irow, icol))\n\n    # Each tablemeta key should have only one position\n    for key in list(result[\"tablemeta\"].keys()):\n        positions = result[\"tablemeta\"][key]\n        if len(positions) &gt; 1:\n            # Use the first found position\n            result[\"tablemeta\"][key] = positions[0]\n\n    # Row metadata (must appear in single columns)\n    rowmeta_df = tmpl_df.loc[:, ~data_cols]  # Metadata columns (non-data)\n\n    for icol, col in rowmeta_df.items():  # Iterate by column\n        key_list = []\n        range_list = []\n        for irow, cell in col.items():\n            if not isinstance(cell, str):\n                continue\n            match_res = re.match(r\"(\\w+)\\[rowmeta\\]\", str(cell))\n            if match_res:\n                key_list.append(match_res.group(1))\n                range_list.append(irow)\n\n        if key_list:\n            # Ensure single key per column and contiguous range\n            unique_keys = set(key_list)\n            assert len(unique_keys) == 1, (\n                f\"Multiple rowmeta keys found in column {icol}: {unique_keys}\"\n            )\n\n            meta_key = next(iter(unique_keys))\n            assert check_int_serial(range_list), (\n                f\"Rowmeta ranges must be contiguous in column {icol}\"\n            )\n            assert set(range_list).issubset(set(data_rows_list)), (\n                f\"Rowmeta rows out of data zone in column {icol}\"\n            )\n\n            result[\"rowmeta\"][meta_key] = {\n                \"col\": icol,\n                \"start\": min(range_list),\n                \"end\": max(range_list),\n            }\n\n    # Column metadata (must appear in single rows)\n    colmeta_df = tmpl_df.loc[~data_rows, :]  # Metadata rows (non-data)\n\n    for irow, row in colmeta_df.iterrows():  # Iterate by row\n        key_list = []\n        range_list = []\n        for icol, cell in enumerate(row):\n            if not isinstance(cell, str):\n                continue\n            match_res = re.match(r\"(\\w+)\\[colmeta\\]\", str(cell))\n            if match_res:\n                key_list.append(match_res.group(1))\n                range_list.append(icol)\n\n        if key_list:\n            # Ensure single key per row and contiguous range\n            unique_keys = set(key_list)\n            assert len(unique_keys) == 1, (\n                f\"Multiple colmeta keys found in row {irow}: {unique_keys}\"\n            )\n\n            meta_key = next(iter(unique_keys))\n            assert check_int_serial(range_list), (\n                f\"Colmeta ranges must be contiguous in row {irow}\"\n            )\n            assert set(range_list).issubset(set(data_cols_list)), (\n                f\"Colmeta columns out of data zone in row {irow}\"\n            )\n\n            result[\"colmeta\"][meta_key] = {\n                \"row\": irow,\n                \"start\": min(range_list),\n                \"end\": max(range_list),\n            }\n\n    return result\n</code></pre>"},{"location":"reference/#minexcel.block.read_block_excel","title":"<code>read_block_excel(path, tmpl, skipheader=0, skipfooter=0, skipleft=0, skipright=0, intervalrows=0, intervalcols=0)</code>","text":"<p>Reads structured Excel data blocks from a file and parses them according to a template.</p> <p>This function processes an Excel file containing multiple structured data blocks separated by specified intervals. Each block is parsed using the provided template definition to extract data.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the Excel file</p> required <code>tmpl</code> <code>Dict[str, Any]</code> <p>Template dictionary defining block structure</p> required <code>skipheader</code> <code>int</code> <p>Number of rows to skip at top of sheet</p> <code>0</code> <code>skipfooter</code> <code>int</code> <p>Number of rows to skip at bottom of sheet</p> <code>0</code> <code>skipleft</code> <code>int</code> <p>Number of columns to skip at left of sheet</p> <code>0</code> <code>skipright</code> <code>int</code> <p>Number of columns to skip at right of sheet</p> <code>0</code> <code>intervalrows</code> <code>int</code> <p>Number of separator rows between vertical blocks</p> <code>0</code> <code>intervalcols</code> <code>int</code> <p>Number of separator columns between horizontal blocks</p> <code>0</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: Concatenated DataFrame containing all parsed blocks in long format</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If sheet dimensions don't fit specified block structure</p> Source code in <code>src/minexcel/block.py</code> <pre><code>def read_block_excel(\n    path: str,\n    tmpl: Dict[str, Any],\n    skipheader: int = 0,\n    skipfooter: int = 0,\n    skipleft: int = 0,\n    skipright: int = 0,\n    intervalrows: int = 0,\n    intervalcols: int = 0,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Reads structured Excel data blocks from a file and parses them according to a template.\n\n    This function processes an Excel file containing multiple structured data blocks separated\n    by specified intervals. Each block is parsed using the provided template definition to extract\n    data.\n\n    Args:\n        path: Path to the Excel file\n        tmpl: Template dictionary defining block structure\n        skipheader: Number of rows to skip at top of sheet\n        skipfooter: Number of rows to skip at bottom of sheet\n        skipleft: Number of columns to skip at left of sheet\n        skipright: Number of columns to skip at right of sheet\n        intervalrows: Number of separator rows between vertical blocks\n        intervalcols: Number of separator columns between horizontal blocks\n\n    Returns:\n        pd.DataFrame: Concatenated DataFrame containing all parsed blocks in long format\n\n    Raises:\n        AssertionError: If sheet dimensions don't fit specified block structure\n\n    \"\"\"\n    # Read Excel file with merged cell handling\n    full = read_excel_with_merged_cell(path)\n\n    # Extract full contents\n    row_start = skipheader\n    row_end = full.shape[0] - skipfooter\n    col_start = skipleft\n    col_end = full.shape[1] - skipright\n\n    full = full.iloc[row_start:row_end, col_start:col_end]\n\n    # Reset index to integer-based for consistent slicing\n    full = pd.DataFrame(full.values)\n\n    # Calculate number of horizontal blocks\n    nblock_in_row = round(full.shape[1] / (tmpl[\"block_ncol\"] + intervalcols))\n    expected_cols = (\n        nblock_in_row * tmpl[\"block_ncol\"] + (nblock_in_row - 1) * intervalcols\n    )\n    assert full.shape[1] == expected_cols, \"Columns don't fit block\"\n\n    # Calculate number of vertical blocks\n    nblock_in_col = round(full.shape[0] / (tmpl[\"block_nrow\"] + intervalrows))\n    expected_rows = (\n        nblock_in_col * tmpl[\"block_nrow\"] + (nblock_in_col - 1) * intervalrows\n    )\n    assert full.shape[0] == expected_rows, \"Rows don't fit block\"\n\n    # Calculate starting positions for each block\n    block_row_starts = [\n        i * tmpl[\"block_nrow\"] + i * intervalrows for i in range(nblock_in_col)\n    ]\n    block_col_starts = [\n        i * tmpl[\"block_ncol\"] + i * intervalcols for i in range(nblock_in_row)\n    ]\n\n    # Extract all valid data blocks\n    blocks = []\n    for row_start in block_row_starts:\n        for col_start in block_col_starts:\n            # Extract block using template dimensions\n            block = full.iloc[\n                range(row_start, row_start + tmpl[\"block_nrow\"]),\n                range(col_start, col_start + tmpl[\"block_ncol\"]),\n            ]\n            # Skip fully empty blocks\n            if all(block.isna().all()):\n                continue\n            blocks.append(block)\n\n    # Parse each block using template and combine results\n    result = [parse_block(b, tmpl) for b in blocks]\n    result = pd.concat(result, axis=0)\n\n    return result\n</code></pre>"},{"location":"reference/#minexcel.utils.read_excel_with_merged_cell","title":"<code>read_excel_with_merged_cell(path, sheetname=None)</code>","text":"<p>Reads an Excel file and processes merged cells by filling the merged area with the top-left cell's value.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Path to the Excel file</p> required <code>sheetname</code> <code>Optional[str]</code> <p>Name of the sheet to read. If None, the active sheet is used</p> <code>None</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the data from the Excel sheet with merged cells processed</p> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the provided sheetname is not in the workbook</p> Source code in <code>src/minexcel/utils.py</code> <pre><code>def read_excel_with_merged_cell(\n    path: str, sheetname: Optional[str] = None\n) -&gt; pd.DataFrame:\n    \"\"\"Reads an Excel file and processes merged cells by filling the merged area with the top-left cell's value.\n\n    Args:\n        path: Path to the Excel file\n        sheetname: Name of the sheet to read. If None, the active sheet is used\n\n    Returns:\n        DataFrame containing the data from the Excel sheet with merged cells processed\n\n    Raises:\n        AssertionError: If the provided sheetname is not in the workbook\n\n    \"\"\"\n    wb = opx.load_workbook(path, data_only=True)\n    if sheetname is None:\n        ws = wb.active\n    else:\n        assert sheetname in wb.sheetnames\n        ws = wb[sheetname]\n\n    merged_ranges = [m for m in ws.merged_cells.ranges]\n\n    for merged_range in merged_ranges:\n        ws.unmerge_cells(str(merged_range))\n\n    for merged_range in merged_ranges:\n        min_col, min_row, max_col, max_row = merged_range.bounds\n        cell_value = ws.cell(row=min_row, column=min_col).value\n\n        for row in range(min_row, max_row + 1):\n            for col in range(min_col, max_col + 1):\n                ws.cell(row=row, column=col).value = cell_value\n\n    df = pd.DataFrame(ws.values, columns=None)\n\n    return df\n</code></pre>"}]}