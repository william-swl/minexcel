{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"minexcel","text":"<p>A package to process excel files</p>"},{"location":"reference/","title":"minexcel","text":""},{"location":"reference/#minexcel.block.parse_template","title":"<code>parse_template(template_file)</code>","text":"<p>Parses an Excel template file to extract metadata information about its structure.</p> <p>This function analyzes an Excel template and returns a dictionary containing: - Dimensions of the entire template and data blocks - Positions of row and column metadata markers - Table-level metadata positions - Validation checks for template structure</p> <p>Parameters:</p> Name Type Description Default <code>template_file</code> <code>str</code> <p>Path to the Excel template file (.xlsx) to be parsed</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>A dictionary with the following structure:</p> <code>Dict[str, Any]</code> <ul> <li>'block_nrow': int,          # Total rows in template</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'block_ncol': int,          # Total columns in template</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'data_nrow': int,           # Number of rows in data zone</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'data_ncol': int,           # Number of columns in data zone</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'data_rows_list': List[int], # Row indices in data zone</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'data_cols_list': List[int], # Column indices in data zone</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'tablemeta': Dict[str, Tuple[int, int]], # Table metadata positions</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'rowmeta': Dict[str, Dict[str, int]],    # Row metadata definitions</li> </ul> <code>Dict[str, Any]</code> <ul> <li>'colmeta': Dict[str, Dict[str, int]]     # Column metadata definitions</li> </ul> <p>Raises:</p> Type Description <code>AssertionError</code> <p>If the template structure doesn't meet requirements:</p> <ul> <li>Data zone must be contiguous</li> <li>Each rowmeta key must appear only in a single column</li> <li>Each colmeta key must appear only in a single row</li> <li>Metadata ranges must be serial and within data zone</li> </ul> Source code in <code>src/minexcel/block.py</code> <pre><code>def parse_template(template_file: str) -&gt; Dict[str, Any]:\n    \"\"\"\n    Parses an Excel template file to extract metadata information about its structure.\n\n    This function analyzes an Excel template and returns a dictionary containing:\n    - Dimensions of the entire template and data blocks\n    - Positions of row and column metadata markers\n    - Table-level metadata positions\n    - Validation checks for template structure\n\n    Args:\n        template_file: Path to the Excel template file (.xlsx) to be parsed\n\n    Returns:\n        A dictionary with the following structure:\n\n        - 'block_nrow': int,          # Total rows in template\n        - 'block_ncol': int,          # Total columns in template\n        - 'data_nrow': int,           # Number of rows in data zone\n        - 'data_ncol': int,           # Number of columns in data zone\n        - 'data_rows_list': List[int], # Row indices in data zone\n        - 'data_cols_list': List[int], # Column indices in data zone\n        - 'tablemeta': Dict[str, Tuple[int, int]], # Table metadata positions\n        - 'rowmeta': Dict[str, Dict[str, int]],    # Row metadata definitions\n        - 'colmeta': Dict[str, Dict[str, int]]     # Column metadata definitions\n\n    Raises:\n        AssertionError: If the template structure doesn't meet requirements:\n\n            - Data zone must be contiguous\n            - Each rowmeta key must appear only in a single column\n            - Each colmeta key must appear only in a single row\n            - Metadata ranges must be serial and within data zone\n\n    \"\"\"\n    result = {\n        \"block_nrow\": None,\n        \"block_ncol\": None,\n        \"data_nrow\": None,\n        \"data_ncol\": None,\n        \"data_rows_list\": None,\n        \"data_cols_list\": None,\n        \"tablemeta\": {},\n        \"rowmeta\": {},\n        \"colmeta\": {},\n    }\n\n    # Load workbook and get active sheet\n    workbook = opx.load_workbook(template_file)\n    template = workbook.active\n\n    # Process merged cells by unmerging and copying top-left value to all cells\n    merged_ranges = [m for m in template.merged_cells.ranges]\n\n    for merged_range in merged_ranges:\n        template.unmerge_cells(str(merged_range))\n\n    for merged_range in merged_ranges:\n        min_col, min_row, max_col, max_row = merged_range.bounds\n        cell_value = template.cell(row=min_row, column=min_col).value\n\n        for row in range(min_row, max_row + 1):\n            for col in range(min_col, max_col + 1):\n                template.cell(row=row, column=col).value = cell_value\n\n    # Convert to DataFrame for easier processing\n    tmpl_df = pd.DataFrame(template.values, columns=None)\n\n    # 1. Get basic dimensions\n    result[\"block_nrow\"], result[\"block_ncol\"] = tmpl_df.shape\n\n    # 2. Identify data zone (non-blank areas)\n    data_cols = tmpl_df.isna().sum(axis=0) != 0\n    data_cols_list = data_cols[data_cols].index.to_list()\n\n    data_rows = tmpl_df.isna().sum(axis=1) != 0\n    data_rows_list = data_rows[data_rows].index.to_list()\n\n    # 3. Validate data zone is contiguous\n    assert check_int_serial(data_cols_list), \"Data columns must be contiguous\"\n    assert check_int_serial(data_rows_list), \"Data rows must be contiguous\"\n\n    result[\"data_cols_list\"] = data_cols_list\n    result[\"data_rows_list\"] = data_rows_list\n    result[\"data_nrow\"], result[\"data_ncol\"] = tmpl_df.loc[data_rows, data_cols].shape\n\n    # 4. Extract metadata\n    # Table-level metadata (can appear anywhere)\n    for irow, row in tmpl_df.iterrows():\n        for icol, cell in enumerate(row):\n            if not isinstance(cell, str):\n                continue\n            match_res = re.match(r\"(\\w+)\\[tablemeta\\]\", str(cell))\n            if match_res:\n                key = match_res.group(1)\n                result[\"tablemeta\"].setdefault(key, []).append((irow, icol))\n\n    # Each tablemeta key should have only one position\n    for key in list(result[\"tablemeta\"].keys()):\n        positions = result[\"tablemeta\"][key]\n        if len(positions) &gt; 1:\n            # Use the first found position\n            result[\"tablemeta\"][key] = positions[0]\n\n    # Row metadata (must appear in single columns)\n    rowmeta_df = tmpl_df.loc[:, ~data_cols]  # Metadata columns (non-data)\n\n    for icol, col in rowmeta_df.items():  # Iterate by column\n        key_list = []\n        range_list = []\n        for irow, cell in col.items():\n            if not isinstance(cell, str):\n                continue\n            match_res = re.match(r\"(\\w+)\\[rowmeta\\]\", str(cell))\n            if match_res:\n                key_list.append(match_res.group(1))\n                range_list.append(irow)\n\n        if key_list:\n            # Ensure single key per column and contiguous range\n            unique_keys = set(key_list)\n            assert len(unique_keys) == 1, (\n                f\"Multiple rowmeta keys found in column {icol}: {unique_keys}\"\n            )\n\n            meta_key = next(iter(unique_keys))\n            assert check_int_serial(range_list), (\n                f\"Rowmeta ranges must be contiguous in column {icol}\"\n            )\n            assert set(range_list).issubset(set(data_rows_list)), (\n                f\"Rowmeta rows out of data zone in column {icol}\"\n            )\n\n            result[\"rowmeta\"][meta_key] = {\n                \"col\": icol,\n                \"start\": min(range_list),\n                \"end\": max(range_list),\n            }\n\n    # Column metadata (must appear in single rows)\n    colmeta_df = tmpl_df.loc[~data_rows, :]  # Metadata rows (non-data)\n\n    for irow, row in colmeta_df.iterrows():  # Iterate by row\n        key_list = []\n        range_list = []\n        for icol, cell in enumerate(row):\n            if not isinstance(cell, str):\n                continue\n            match_res = re.match(r\"(\\w+)\\[colmeta\\]\", str(cell))\n            if match_res:\n                key_list.append(match_res.group(1))\n                range_list.append(icol)\n\n        if key_list:\n            # Ensure single key per row and contiguous range\n            unique_keys = set(key_list)\n            assert len(unique_keys) == 1, (\n                f\"Multiple colmeta keys found in row {irow}: {unique_keys}\"\n            )\n\n            meta_key = next(iter(unique_keys))\n            assert check_int_serial(range_list), (\n                f\"Colmeta ranges must be contiguous in row {irow}\"\n            )\n            assert set(range_list).issubset(set(data_cols_list)), (\n                f\"Colmeta columns out of data zone in row {irow}\"\n            )\n\n            result[\"colmeta\"][meta_key] = {\n                \"row\": irow,\n                \"start\": min(range_list),\n                \"end\": max(range_list),\n            }\n\n    return result\n</code></pre>"}]}